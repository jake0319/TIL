# 배열과 리스트

## 배열(Array)
- 가장 기본적 자료구조
- 여러 개의 변수를 담는 공간
- `index`가 존재, 0부터 시작
- `특정한 인덱스에 직접적으로 접근 가능 : 수행시간 O(1) : 1회의 연산 `
-  컴퓨터의 메인 `메모리에서 배열의 공간은 연속적`으로 할당된다.

1. 장점: 원소를 인접한 메모리 주소에 순차적으로 담아서 캐시(cache)히트 가능성이 높으며, 조회가 빠르다.
2. 배열의 크기를 미리 지정해야 하는 것이 일반적이므로, 데이터의 추가 및 삭제에 한계가 있다. 
// js에서 배열은 동적배열이므로, 배열의 크기가 정해져있지 않음

<br>

## 연결리스트(Linked List)
- 연결 리스트는 컴퓨터의 메인 메모리상에서 주소가 연속적이지 않다.
- 배열과 다르게 크기가 정해져 있지 않고, `리스트이 크기는 동적으로 변경 가능하다.`
1. 장점: 포인터를 통해 다음 데이터의 위치를 가리킨다는 점에서 `삽입과 삭제가 간편`하다.
//  머리 - `[값+포인터변수(다음 데이터의 주소를 담는 변수)` - 꼬리 
2. 단점: 특정 번째의 원소를 검색할 때는 앞에서부터 원소를 찾아야 하므로`(Linked한 특성)`, `데이터 검색 속도가 느리다.`

<br>

### Javascript의 배열
- 일반적인 프로그래밍 언어에서의 `배열`로 이해할 수 있음
- js 배열은 `일반 배열처럼 임의의 인덱스를` 이용해 직접적인 접근이 가능하다.
- js의 배열은 `동적 배열`의 기능을 제공하여, 맨 뒤의 위치에 원소 추가가 가능하다.
- `동적 배열` : 배열의 용량이 가득 차면, 자동으로 크기를 증가
- 내부적으로 `포인터를 사용하여 연결 리스트`의 장점도 가지고 있음(`원소 추가,삭제가 빠름`)
- `배열 혹은 스택`의` 기능이 필요할 때 이러한 동적배열을 사용할 수 있음.
- `큐(queue:선입선출)`의 기능을 제공하지 못한다.(비효율적) `별도의 구현이 필요하다`

<br>

### JS배열 초기화 
1. `let arr = [];` 리터럴로 생성하기
2. `let arr = new Array()` 배열 생성자함수로 생성하기, ()에는 크기가 들어간다.
>const arr1 = new Array(); // 빈 배열 생성
const arr2 = new Array(5); // 길이가 5인 배열 생성 (특정 상황에서만 사용)
const arr3 = new Array("apple", "banana", "orange"); // 요소가 "apple", "banana", "orange"인 배열 생성
주의할 점은, 배열 생성자 함수를 사용하지 않고 대괄호([])를 사용하여 배열을 생성하는 것이 더 일반적이며, 더욱 간결하고 가독성이 좋습니다.
3. 일반적인 변수 외에도 객체를 담을 수 있음
4. 원하는 값을 직접 입력하여 초기화 할 수 있음.
```js
let arr2 = Array.from( {length: 5}, ()=> 7);
console.log(arr2) // [7,7,7,7,7];
```
5. 2차원 배열이 필요한 경우는 직접 원하는 값을 넣어서 초기화한다. 
` [ arr1 , arr2, arr3 ]``
6. `크기가 NxM인 2차원 리스트(배열)만들기`
```js
let arr = Array.from(Array(4), ()=> new Array(5))
// 크기가 4인 배열인데, 각 원소또한 크기가 5인 배열임
console.log(arr);

//실행결과
[
   [ <5 empty items> ],
   [ <5 empty items> ],
   [ <5 empty items> ],
   [ <5 empty items> ]
]
```
7. `반복문으로 2차원 리스트(배열)만들기!`
```js
let arr2 = new Array(3);
for (let i =0; i < arr2.length; i++){
   arr2[i] = Array.from (
     { length: 4 } , //첫번째 파라미터에는 이터러블 혹은 유사배열객체가 들어간다 .
     (undefined, j) => i * 4 + j 
     //undefined는 {length:4}라는 유사배열객체 혹은 이터러블의 value, j는 해당 인덱스 
   );
}
console.log(arr2);
```
8. 배열이 생성된 이후에도 배열의 크기를 임의로 변경할 수 있음.
`let arr = [1,2,3,4,5]; , arr.length = 8; `
9. concat(): 여러개의 배열을 이어붙여서 합친 결과를 반환. O(N)
```js
let arr1 =[1,2,3,4,5];
let arr2 =[6,7,8,9,10];
let arr = arr1.concat(arr2, [11,12], [13]); //추가되는 파라미터가 배열인경우 원소값만 뽑아서추가(새로운배열로)
console.log(arr); //[1,2,3,4,5,6,7,8,9,10,11,12,13]
```
10. slice(n,m) // index n에서 m-1까지 원소를 가져온 배열 리턴 
```js
let arr = [1,2,3,4,5];
let res = arr.slice(2,4); //idx 2~3까지 뽑아냄
console.log(res); // [3,4]
```
- 사용빈도가 높으므로 꼭 외우기 
11. indexOf(): 특정한 값을 가지는 원소의 첫째 인덱스를 반환. O(N)
- 만약 값이 없다면 -1 
```js
let arr = [7,3,5,6,6,2,1];
console.log(arr.indexOf(6)); // 3 : 가장 첫 번째 인덱스를 딱 하나만 반환!
```

<br>

### 연결리스트
- `각 노드가 한 줄로 연결`되어 있는 자료구조
- 각 노드는(데이터,포인터)형태를 가진다. // 데이터 + 다음 데이터의 주소
- `포인터: 다음 노드의 메모리 주소`를 가리키는 목적으로 사용된다. 
- `연결리스트를 이용하면 다양한 자료를 구현할 수 있음( stack , queue) `
-  js는 연결리스트를 활용하는 자료구조를 제공한다.


### 연결리스트 vs 배열 
- 연결리스트와 배열의 장단점을 이해할 필요가 있음
- 특정 위치의 데이터를 삭제할 때 `배열은 O(N):최악의 경우` (추가시 한칸씩 밀어주기, 삭제시 삭제후 한칸씩 당기기과정)
- `연결리스트`는 단순히 연결만 끊어주면 됨, 따라서 삭제할 위치를 정확히 알고 있다면 O(1)
- 반면 연결리스트는 삽입 위치 전 원소의 포인터가 삽입 데이터의 주소값을 가리키게하고, 삽입데이터의 포인터가 다음 데이터의 주소를 가리키게 만들어주면 됨.(중간에 끼워넣기가 가능함)





