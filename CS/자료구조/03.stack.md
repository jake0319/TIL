# STACK 기본 개념 
- 선입후출: 먼저 들어온 데이터가 나중에 나가는 
- ( 프링글스 통 모양의 자료구조 )
- 새로운 원소를 삭제할 때는 마지막 원소가 삭제된다.
-  `ㄷ`모양의 통에 `<-삽입방향 | 삭제방향->`, 머리(head)= 최상의원소 위치에서 삽입|삭제 , 로 생각

<br>

## 스택 자료구조의 시간복잡도 
- 스택은 여러가지 연산을 제공한다. (삽입,추출,최상위원소확인(top),empty)
|id|연산|시간복잡도|설명|
|------|---|---|---|
|1|삽입(Push)|O(1)|스택에 원소를 삽입하는 연산(head에서)| 
|2|추출(Pop)|O(1)|스택에서 원소를 추출하는 연산(head에서)|
|3|최상위 원소(Top)|O(1)|스택의 최상위 원소(마지막에 들어온 원소)를 확인하는 연산|
|4|Empty|O(1)|스태기 비어있는지 확인하는 연산|

<br>

### Javascript에서 stack구현 방법 - 배열 자료형
- js의 기본적인 배열 자료형은 다음의 두 가지 메서드를 제공
- push() : 마지막 위치에 원소를 삽입  ,O(1)
- pop() : 마지막 위치에서 원소를 추출 ,O(1)
__` js에서 stack구현시 배열을 그대로 가져다 쓰는 것이 합리적임!`__

```js
let stack = []
stack.push(5);
stack.push(2);
stack.push(3);
stack.push(7);
stack.pop();
stack.push(1);
stack.push(4);
stack.pop();

let reversed = stack.slic().reverse(); // stack배열을 복제후 역순으로 
console.log(reversed);
console.log(stack);
```

<br>

### 연결리스트로 스택 구현하기
- 스택을 연결리스트로 구현하면 삽입과 삭제에 있어서 O(1)을 보장받을 수 있다!
- 연결 리스트로 구현할 때는 머리(head)를 가리키는 한 개의 포인터만 가진다.
- `head: 남아있는 원소 중 가장 마지막에 들어 온 데이터를 가리키는 포인터.`

### 연결리스트로 스택 구현하기 - 삽입연산
1. 삽입할 때는 head위치에 데이터를 넣는다
2. 삽입한 데이터의 포인터가 이전의 top 데이터주소를 가리키도록 한다.

<br>

1. 삭제할 때는 head 위치에서 데이터를 꺼낸다.
2. 머리 위치가 최상단 데이터를 가리키도록한다.


