# TOC



[반드시 알아둬야 할 자료구조 STACK,QUEUE](#반드시-알아둬야-할-자료구조-stackqueue)  

- [1.스택 자료구조(후입선출)](#1스택-자료구조후입선출)

- [2.큐 자료구조(선입선출,FIFO)](#2큐-자료구조선입선출fifo)

[재귀함수(Recursive Function)](#재귀함수recursive-function)  

- [재귀함수의 종료조건](#재귀함수의-종료조건)  

- [팩토리얼 구현 예제](#팩토리얼-구현-예제)  

- [최대 공약수(유클리드 호제법) 예제](#최대-공약수유클리드-호제법-예제)   

- [재귀 함수 사용의 유의사항](#재귀-함수-사용의-유의사항)

[DFS/BFS](dfsbfs)  
- [DFS(Depth-First Search)](#dfsdepthfirst-search)  

- [DFS 소스코드 예제](#dfs-소스코드-예제)  

- [BFS(Breadth-First Search)](#bfsbreadthfirst-search)  

- [BFS 소스코드 예제](#bfs-소스코드-예제)

[DFS/BFS 기초 문제풀이](dfsbfs-기초-문제풀이)
- [<DFS문제> 음료수 얼려 먹기: 문제설명](#dfs문제-음료수-얼려-먹기-문제설명)
- [<BFS문제> 미로 탈출: 문제설명](#bfs문제-미로-탈출-문제설명)

<br><br>


# 완전탐색 
- 완전탐색은 간단히 가능한 모든 경우의 수를 다 체크해서 정답을 찾는 방법이다.
- 이 방법은 무식하게 한다는 의미로 `Brute Force`라고도 부르며, 직관적이어서 이해하기 쉽고 문제의 정확한 결과값을 얻어낼 수 있는 가장 확실하며 기초적인 방법이다.

## 완전탐색 기법을 활용하는 방법
① Brute Force 기법 - 반복 / 조건문을 활용해 모두 테스트하는 방법  
② 순열(Permutation) - n개의 원소 중 r개의 원소를 중복 허용 없이 나열하는 방법  
③ 재귀 호출  
④ 비트마스크 - 2진수 표현 기법을 활용하는 방법  
⑤ BFS, DFS를 활용하는 방법  
>DFS는 깊이 우선 탐색으로 현재 인접한 정점을 탐색 후 그 다음 인접한 정점을 탐색하여 끝까지 탐색하는 방식이다.  
BFS는 너비 우선 탐색으로 현재 정점과 인접한 정점을 우선으로 탐색하고




<br>



# 완전탐색
- 탐색: 많은 양의 데이터중 `원하는 데이터를 찾는 과정`
- 대표적 그래프 탐색 알고리즘: `DFS,BFS`


## 반드시 알아둬야 할 자료구조 STACK,QUEUE

### 1.스택 자료구조(후입선출)
- 입구와 출구가 동일한 형태 // 프링글스 과자 통같은 이미지 연상
- 가장 마지막에 들어온 데이터가 먼저 나가는 형식(후입선출LIFO)
- 파이썬에서는 별도의 자료구조없이 list[]형태로 스택 구현가능

<br>

- __스택 구현 예제__
```python
stack = []
stack.append(5) # 스택자료구조 최하단에 5 추가
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()    #가장 마지막 들어온 7 삭제 
stack.append(1)
stack.append(4)
stack.pop()    #가장 마지막 4 삭제 
			
print(stack[::-1]  #[5,2,3,1]의처음부터 끝까지 왼쪽으로 1칸씩 이동하며 가져옴 [1,2,3,5] (최상단원소부터 출력)
print(stack) # 최하단원소부터 출력 [5,2,3,1]
```

> 파이썬 이터러블(리스트,튜플,문자열..) 슬라이싱  
a[start : end : step]  
a[start:] //시작위치부터 끝까지  
a[:end] // 시작적부터 특정위치까지  
a[start:end] //특정위치부터 특정위치까지  
>> step의 예제
a[ start : end : step ]
-step이 양수일 때: 오른쪽으로 step만큼 이동하면서 가져옵니다.
-step이 음수일 때: 왼쪽으로 step만큼 이동하면서 가져옵니다.
a[::2] // 2칸씩 이동하면서 가져옴  [1,3,5]
a[-5::3] //뒤에서 5번째부터 끝까지 3칸씩이동하면서가져옴 [1,4]
a[::-1] //처음부터 끝까지 뒤에서 1칸씩 왼쪽으로 이동하며 가져옴 [5,4,3,2,1]


### 2.큐 자료구조(선입선출,FIFO)
- 먼저 들어 온 데이터가 먼저 나가는 (선입선출)형식의 자료구조
- 큐는 입구와 출구가 모두 뚫려있는 `터널과 같은 형태`로 시각화가능 
- `from collections import deque` //덱 라이브러리 import해서 큐 구현
// list로 큐 구현시 기능적으론 OK, but 시간복잡도 증가하므로 deque 덱 라이브러리를 활용한다.
- 큐는 출력시 덱 객체로 출력된다. `deque([요소 리스트])`
<br>

- __큐 자료구조 예제__
```python  
from collections import deque 

# 덱메서드 호출로 큐 생성
queue = deque() 

# 5 2, 3, 7, -삭제() , 1, 4, -삭제()
queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)    #deque([7, 3 ,2 ,5 ])
queue.popleft()   # 먼저들어온 것(5) 삭제 
queue.append(1)
queue.append(4)    #deque([4,1,7,3,2])
queue.popleft()    #deque([4,1,7,3])

print(queue) #먼저 들어온 순서대로 출력, deque([3,7,1,4])
queue.reverse() #역순으로 바꾸기 [4,1,7,3]
print(queue)   #deque([4,1,7,3])
```


## 재귀함수(Recursive Function)
- `자기 자신을 다시 호출하는 함수`
```python
def recursive_function():
	print('재귀함수를호출합니다')
	recursive_function()

recursive_function()
```

<br>


- 파이썬은 재귀를 호출하는 과정에서 `재귀 깊이 제한`이 있음(리컬젼에러)

### 재귀함수의 종료조건
- 재귀 함수를 문제 풀이에서 사용할 경우 `재귀함수의 종료 조건을 반드시 명시해야함.`
- 종료 조건을 명시하지 않는다면 함수가 무한 호출되기 때문
```python
def recursive_function(i):
	#100번재 호출 했을 때 종료되도록 종료 조건 명시
	if i == 100:
		return 
	print(i, '번째 재귀함수에서', i + 1 , '번째 재귀함수를 호출합니다.')
	recursive_function(i + 1)
	print(i, '번째 재귀함수를 종료합니다.')

recursive_function(1)
```

<br>

### 팩토리얼 구현 예제
- n! = 1 x 2 x 3 ....x (n-1) x n 
- 0!, 1! = 1입니다.

```python
# 반복적으로 구현한 n!
def factorial_iterative(n):
	result=1
	# 1부터 n까지 수를 차례로 곱하기
	for i in range(1,n+1):
		result *= i  #reduce하게
	return result

# 재귀적으로 구현한 n!
def factorial_recursive(n):
	if n<=1 : #n이 1 이하인경우 1반환
		return 1
	# n! = n x (n-1)! 을 그대로 코드로 작성
	return n x factorial_recursive(n-1)

# 각각의 방식으로 구현한 팩토리얼 (n=5)
print('반복적으로 구현:', factorial_iterative(5))
print('재귀적으로 구현:', factorial_recursive(5))
```

<br>

### 최대 공약수(유클리드 호제법) 예제
- 두 개의 자연수에 대한 최대공약수를 구하는 대표적 알고리즘: `유클리드 호제법`
- __유클리드 호제법__
	1. 두 자연수 A,B에 대하여 (A>B) A를 B로 나눈 나머지를 R이라고 함.
	2. 이때 A와 B의 최대공약수는 B와 R의 최대공약수와 같음.
// GCD<A,B> = GCD<B,R(나머지)>
- `유클리드 호제법의 아이디어`를 그대로 `재귀함수`로 작성할 수 있음.
// GCD(192,162) = GCD(162,30) = GCD(30,12) = GCD(12,6) = 6 

<br>

```python
def gcd(a,b):
	if a % b == 0:
		return b   #나누어 떨어지면 b가 gcd
	else: 
		return gcd(b, a % b)

print(gcd(192,162)
```

### 재귀 함수 사용의 유의사항
- 재귀함수를 잘 쓰면 복잡한 알고리즘을 간결하게 작성할 수 있음
- `모든 재귀함수는 반복문을 이용하여 동일한 기능을 구현할 수 있음`
- 재귀함수가 반복문보다 유리한 경우도 있고 불리한 경우도 있음
- 컴퓨터가 함수를 연속적으로 호출하면 메모리 내부의 스택 프레임에 쌓임,
	- 그래서 스택을 사용해야 할 때 구현상 `스택 라이브러리 대신 재귀 함수를 이용`하는 경우가 많음 


<br>

## DFS(Depth-First Search)
- 깊이 우선 탐색, 그래프에서 `깊은 부분을 우선적으로 탐색하는 알고리즘`
- DFS는 `스택자료구조(혹은 재귀함수)를 이용`
1. 탐색 시작 노드(1)를 스택에 삽입 후 방문처리 
// 방문기준: 번호가 낮은 인접 노드부터 
2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문처리,
방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄.
3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복(재귀)

<br>

![image](https://user-images.githubusercontent.com/78556338/221400598-7cb612d0-b84b-47f1-b752-8d1d1009f312.png)

> 1-> (2_check ,3,8) : 인접노드중 가장 낮은번호의 2번노드 방문처리후 다시 DFS진행  
-> (1, 7_check) : 방문노드인 1제외 인접노드 7 방문처리(스택 최상단넣기)  
-> 스택 최상단 노드 7 기준으로 방문하지 않은 (6_check,8)중 6을 스택에 넣고 방문처리    
-> 노드 6에서 더 이상 방문하지 않은 노드가 없으므로 스택에서 pop()  
-> 다시 스택의 최상단노드 7에 방문하지 않은 인접노드 8이 있으므로 방문처리   
-> 스택최상단 8번노드에서는 인접노드가 모두 방문노드이므로 스택 최상단에서 모두 pop()하며 회귀   
-> 다시 1번노드에서 방문하지 않은 3번노드 방문처리   
-> 최상단 3번노드에서 4방문   
-> 4에서 5방문후 종료   
//탐색순서는 1 2 7 6 8 3 4 5 
__`[요약] 1번노드부터 시작해서,  인접노드중 번호가 낮은대로 방문처리, 인접노드중 방문할 노드가 없다면(모두방문했다면) stack.pop()하며 방문노드 탐색
이러한 방식으로 노드를 가장 깊숙히 탐색하는 방법인 DFS(깊이우선탐색) 이라고한다.`__

### DFS 소스코드 예제
```python
# DFS 메서드 정의 : 인접노드중 방문하지 않는 노드 방문처리후 거기서 다시 dfs탐색 시작
# 초기화해둔 graph, 방문노드v(1 start), visited(방문처리 리스트) 를 파라미터로
def dfs(graph, v, visited):
	visited[v] = True
	print(v, end=' ')
	for i in graph[v]:
		if not visited[i]: 	#방문처리되지 않았다면 해당노드i에서 dfs재귀호출
			dfs(graph, i , visitied)
# 인접노드 정보를 2차원 리스트로 표현 (노드번호가 1번부터이므로 0번인덱스는 없으므로 []빈 리스트로 표시, 방문 리스트도 노드+1개로 초기화)
graph = [
	[],
	[2,3,8],	# 1번 노드의 인접노드 목록
	[1,7],	# 2번 노드의 인접노드
	[1,4,5],
	[3,5],
	[3,4],
	[7],
	[2,6,8],
	[1,7],
]

visited = [False] * 9 # 방문처리 리스트 초기화 (node +1 )

# DFS메서드 호출
dfs(graph, 1 ,visited)  # 1번노드부터 방문처리후 탐색시작하므로..
```
- stack자료구조 , 재귀함수 호출 , 반복문 이용

<br>
<br>

## BFS(Breadth-First Search)
- 너비우선탐색, 그래프에서 가장 가까운 노드부터 우선적으로 탐색
- BFS는 `큐 자료구조를 이용`
1. 탐색 시작 노드를 큐에 삽입하고 방문처리
2. 큐에서 노드를 꺼낸(popleft())뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문처리
3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복


<br>

![image](https://user-images.githubusercontent.com/78556338/221403009-370fe2cb-b2cb-4e59-bef0-6438b804c227.png)

>1. 그래프를 준비(방문기준: 번호가 낮은 인접노드부터)  
2. 시작노드인 1번노드를 큐(터널)에 삽입하고 방문처리(위에서 들어와서 아래로 나간다고 가정)
3. 큐에서 1번노드를 꺼내 방문하지 않은 2,3,8을 큐에 삽입하고 방문처리  
//DFS의 인접노드중 가장 낮은 번호의 노드만 방문처리하는 것과 차이가 있음.  
4. 큐에서 노드2(나갈노드)를 꺼내 방문하지 않은 인접노드 7을 큐에 삽입하고 방문처리  
5. 그 뒤에 꺼낼 3번노드를 꺼내서 방문하지 않은 인접노드 4,5를 큐에 넣고 방문처리 
//탐색순서: 1 -> popleft(1) -> (2 , 3 , 8) -> popleft(2) - > append(7) -> popleft(3) -> 4,5추가 -> popleft(8) -> popleft(7)
-> append(6)  // [탐색(큐 삽입)순서: 1 2 3 8 7 4 5 6] 

>DFS는 더이상 방문할 노드가 없다면 거기서 스택.pop()하며 뒤돌아가서 다시 dfs탐색(방문하지 않은 인접노드중 번호가 더 낮은 하나의노드 방문처리) 시작하지만  
BFS는 큐에 들어온 순서대로 popleft를 수행하며 꺼낸 가장 앞단의 노드에서 BFS탐색(인접노드중 방문하지 않은 노드를 큐에 넣고 모두 방문처리,방문하지 않은 노드가 없다면 무시하고 진행) 실행


### BFS 소스코드 예제
```python
from collections import deque 
# BFS메서드정의
def bfs(graph, start, visited):
	#큐 구현을 위해 덱 라이브러리 사용
	queue = deque([start]) # 해당 리스트의 요소를 갖는 큐 생성( 리스트형태로 넣어야함)
	visited[start] = True # 1번노드를 큐에넣고 방문처리
	while queue:   # 큐가 빌때까지 반복(노드가 모두 방문처리된 상태라면 큐에선 요소가 계속popleft()만됨)
		# 큐에서 1번노드 뽑아내기(탐색완료) 후 인접노드 방문처리
		v = queue.popleft()
		print(v, end=' ') 	# popleft()값이 노드 탐색순서
		for i in graph[v]:	
			if not visited[i]:  #visited[2] , 3 ,8 값이 false면 동작
				queue.append(i)	
				visited[i] = True # 2,3,8노드 큐에 넣고 방문처리 

graph = [
	[], # 존재하지않는 0번노드 
	[2,3,8], #1번노드의 인접노드들
	[1,7],
	[1,4,5],
	[3,5],
	[3,4],
	[7],
	[2,6,8],
	[1,7],
]

visited = [False] * 9 # 1~8번 노드의 방문처리 여부 리스트 
bfs(graph, start , visited)
```
코드작성 순서
1. BFS메서드정의( 큐 구현, 방문처리 로직작성 등..)
2. 인접노드 `그래프 초기화`
3. bfs메서드호출


<br>

## DFS/BFS 기초 문제풀이 

### <DFS문제> 음료수 얼려 먹기: 문제설명

<img width="1088" alt="image" src="https://user-images.githubusercontent.com/78556338/221477101-b0db6139-e48f-4b8c-bb83-bc8db31c0b93.png">

> NxM얼음틀 존재 , 음료를 담을 수 있는칸은0, 없는칸은1  
0으로 연결된 부분은 얼음 한 덩어리로 취급하여, 제시된 그래프에서 생성될 수 있는 얼음의 개수를 구하시오.

<br>

### <DFS문제> 음료수 얼려 먹기: 문제 해결 아이디어
- N x M 얼음틀에서 상하좌우로 연결되어있는 노드들은 인접노드로 간주( 노드:0 , 불가:1 )
- 특정 지점에서 DFS/BFS실행 (`모든` 노드에 대해 방문처리 진행
__DFS활용 알고리즘__
1. 특정 지점의 주변 `상,하,좌,우`를 살펴본 뒤 주변 지점 중에서 값이 0 이면서 아직 방문하지 않은 지점 -> 방문처리
2. 방문한 지점에서 다시 상,하,좌,우를 살펴보면서 방문을 진행하는 과정을 반복하면 `연결된 모든 지점을 방문처리할 수 있음`
3. 1~2 과정을 반복
```python

def dfs(x,y): 	#x,y지점에서 dfs실행 결과
	if x<= -1 or x>= n or y <= -1 or y>=m:    #주어진 범위를 벗어나는 경우 즉시종료(range함수에따라 x,y : 0~ n-1,m-1까지만 탐색)
		return False
	if graph[x][y] ==0: #그래프의 x,y지점에서 아직 방문하지 않았다면(값이 0인 노드를 방문처리하는 것)
		graph[x][y] = 1		# x,y지점에서 0->1 변경 후 방문처리
		dfs(x - 1,y)   # x,y노드의 '좌' 방문처리 
		dfs(x, y - 1)  # x,y노드의 '하' 방문처리
		dfs(x + 1,y)   # 상 
		dfs(x, y + 1)	# 우 
		return True       # x,y지점의 노드에서 상하좌우dfs실행후 방문처리
	return False		#만약 x,y지점의 노드 값이 0이아니라 1이면 dfs(x,y)호출값 False 

# 즉, dfs메서드는 맵의 모든지점에서 dfs를재귀적으로 수행하는데, 이것은 노드의 0,1을 판별해서 0이면 True, 1이면 False를 리턴하는과정 .
# DFS는 노드를 한번에 하나씩만 방문처리하는 특징이 있음(DFS는 특정 노드 방문시 인접노드를 모두 방문처리후 더이상 방문할 곳이 없을 때 popleft())

# n줄(세로 행길이)에 걸쳐서 맵 정보 입력받기
n, m = map(int, input().split()) 
# 공백 기준 입력으로 NxM 맵 크기 정의 (input():문자열입력 ->.split():문자요소 리스트->숫자요소 리스트의 맵객체->언패킹)

# 2차원 리스트의 맵 정보 입력
graph  = []
for i in range(n):
	graph.append(list(map(int,input())))  # N행에 대해 0,1로 구성된 맵 정보 입력 01111,01010,01101 ...
# 모든 노드에 대하여 음료수 채우기
result = 0    # 얼음 갯수 
for i in range(n):    # 세로길이n = 행 개수
	for j in range(m):   # 가로길이m = 열 개수
		if dfs(i,j) == True:      # 모든 지점을 순회하며 dfs(i,j)실행
			result +=1 		
print(resutl) #정답 출력
```
- __요약__
1. dfs메서드는 특정지점 (x,y)그리고 그것의 상하좌우 지점을 재귀적으로 dfs탐색한다. 
2. (x,y)에서 탐색시 해당 지점에서 연결된 모든 노드(방문하지않아 그래프 값이 0인)를 방문처리(0->1)하고 dfs(x,y)는 True를 리턴 
3. dfs메서드에서 재귀적으로 호출되는 dfs는 True,False만 리턴하고 이 값은 사용되지 않는다.(오로지 x,y 지점에서의 호출값만 사용됨)
4. N x M 맵의 모든 지점에서 dfs호출을 이중반복문으로 처리하고, 그중 dfs(i,j)호출값이 True인 지점의 노드갯수만 result += 1로 집계
5. result값을 전역으로 출력하면 해당 결과 값이 얼음의 개수가 된다. 전역으로 사용되는 변수( graph ,  result , n, m )


<br><br>

### <BFS문제> 미로 탈출: 문제설명


<img width="1085" alt="image" src="https://user-images.githubusercontent.com/78556338/221477272-52f651ee-d21a-491b-a6fa-97a4ec0cc81e.png">

> N x M 크기의 짖ㄱ사각형 형태의 미로에 갇힘, 미로에는 여러마리 괴물이 있어 이를 피해 탈출해야함.  
동빈이의 위치는(1,1)이고, 미로의 출구는(N,M)의 위치에 존재, 한 번에 한 칸씩 이동가능  
이 때, 괴물이 존재하는칸은 0, 없는 칸은 1 (미로는 반드시 탈출가능한 형태로 제시)  
이 때 동빈이가 (1,1) -> (N,M)까지 괴물이 없는 칸으로만 이동해서 탈출하기 위해 움직여야하는  최소 칸의 개수를 구하시오.  
(칸을 셀 때는 시작 칸과 마지막 칸을 모두 포함해야함)

<br>


>입력예  
5 6  
101010  
111111  
000001  
111111  
111111  
  출력예: 10  


<br>

### 미로 탈출: 문제 해결 아이디어 
- BFS는 간선의 길이가 모두 같을 때(한 칸 이동시 들어가는 비용이 동일) `최단거리`를 탐색하기 위해 사용하는 알고리즘입니다.
- BFS는 시작지점에서 가까운 노드부터 차례대로 그래프의 모든 노드를 탐색합니다.
- 상,하,좌,우로 연결된 모든 노드로의 거리가 1로 동일(=모든 간선의 비용이 동일)
// 따라서 (1,1) 지점부터 BFS를 수행하여 모든 노드의 최단 거리 값을 기록하면 해결할 수 있음. 

<br>

> 입력예)
110111
010011
011111
000111

1. [STEP1] (1,1)에서 시작
2. [STEP2] (1,1)좌표에서 상하좌우로 탐색을 진행하면 바로 옆 노드인(1,2)위치의 노드를 방문하게 되고 새롭게 방문하는 (1,2)노드의 값을 2로 바꾸게됨
// 시작위치와 마지막위치까지 이동하는 최단거리를 찾아야 하므로 이것을 노드값으로 하여 매 지점 탐색과정에서 갱신함.   
3. [STEP3] 마찬가지로 BFS를 계속 수행하면 결과적으로 다음과 같이 최단 경로의 값들이 1씩 증가하는 형태로 변경됨.

<br>

### 미로 탈출: 답안예시(python)
```python
# 큐에 데이터가 존재하는 이상 반복
# BFS는 시작점에서 상하좌우 인접노드들을 탐색하며 해당 지점의 그래프값이 1이면 방문처리 (좌표들을 queue에 모두 append)하고
# 반복문(while문)으로 bfs탐색 : 상하좌우 지점에서 각각 방문가능한경우(1인경우만) queue의 (nx,ny)값 최신화 
# 반복하다가 더이상 반복 불가시 return graph[n-1,m-1] (맨오른쪽 아래지점)의 노드값 출력 (간선비용이 모두 1로 같으므로..)

#bfs 메서드 정의
def bfs(x,y):
	queue = deque()		#빈 큐 생성 
	queue.append((x,y))	# 파라미터로 입력한 x,y좌표를 (x,y)튜플로 큐에 추가 (초기값 0,0)
	# 큐가 빌 때까지 반복, 큐가 비면 노드값(최우하단 좌표) 리턴
	while queue:
		x, y = queue.popleft()	#큐 최하단에 위치한 리스트원소 꺼내서 언팩
		# 현재 위치(x,y)에서 상하좌우 노드 탐색, 탐색 성공 노드 값에 1추가 
		for i in range(4):
			nx = x + dx[i] #탐색 x좌표
			ny = y + dy[i] #탐색 y좌표
			# 이동할 수 없는 범위는 while문으로 복귀
			if nx<0 or nx>=n or ny < 0 or ny >=m:
				continue  #다음 While동작
			# 탐색좌표의 노드값이 0(괴물로 가로막힌 곳이며 이동불가)
			if graph[nx][ny] == 0: 
				contiune  #다음 While동작
			# 탐색좌표가 이동가능한 곳이면
			if graph[nx][ny] == 1: 
				# 탐색좌표의 노드값에 +1
				graph[nx][ny] = graph[x][y] + 1 
				# 탐색성공 좌표(nx,ny)를 큐에 삽입
				queue.append((nx,ny))  # 방문가능 모든 노드좌표를 큐에 모두 삽입( x = nx,y =ny로 while문 반복)
				# 큐가 비어있지 않으므로 while문 반복
	return graph[n-1][m-1] # 큐가 비어지면 bfs메서드는 오른쪽최하단 좌표의 노드값(경로비용)을 리턴
	
from collections import deque #덱 라이브러리 임포트
	
n, m = list(map(int, input().split()))) #space로 구분한 문자열을 숫자로바꾸고 언팩하기 위해 리스트화)

graph = [] # 이차원 리스트 형태의 맵
for i in range(n):  # 맵형태를 n줄로 입력
	graph.append(list(map(int,input())))  # 101010 형태로 입력한 문자열을 순회하며 int map적용 -> list화해서 큐에 삽입 
	
# 이동할 네 방향 정의
dx = [-1,1,0,0]
dy = [0,0,-1,1]

print(bfs(0,0))

```
- BFS 탐색과정은 시작 노드에서 상하좌우 노드를 탐색
- 시작노드 (x,y)좌표의 이차원리스트형태의 그래프값(노드값) 확인을 통해 이동가능(1)이면 노드값+1 불가능이면 pass
- 그래프값이 1이어서 탐색가능노드면 해당노드로 이동한 뒤 큐에 좌표를 추가하고, 노드값에 1을 더한값으로 초기화 

<br>

> 시작점에서 상하좌우 탐색  
->이동가능하면 해당좌표들을 모두 큐에 순차적으로 추가후 노드값+1  
-> 큐에 추가한 좌표를 꺼내서 해당좌표에서 상하좌우 탐색반복  
-> 모두 막혀있는 곳에 도달해서 이동 불가시 큐에서 튜플좌표 popleft()  
-> 큐가 빌 때까지 요소 꺼내기  
-> 결국 모든 이동가능 지점은 탐색되어 노드값이 추가됨  
-> 우측최하단 노드값은 누적되어 최단경로비용이 구해짐



### 출처:  

[이코테 3.DFS&BFS](https://www.youtube.com/watch?v=7C9RgOcvkvo&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=4)
