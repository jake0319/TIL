# 1강. 코딩테스트 개요 및 출제경향
`개발환경: repl.it`
- 자주 사용하는 알고리즘 코드를 라이브러리화 (팀노트작성)
- 가장출제빈도 높은 유형
 1. 그리디(쉬운 난이도)
 2. 구현
 3. DFS/BFS를 활용한 탐색

## IT기업 코딩 테스트 최신 출제 경향(2016~2019)
`[비중높음] BFS/DFS -그리디 - 정렬 - 다이나믹프로그래밍 - 이진탐색 - 최단경로 - 그래프이론 [비중낮음]`

>필수학습개념:
(누적합,구현,그래프이론,DFS/BFS,트리순회,완전탐색,백트래킹,비트마스킹,그리디,라인스위핑
,투포인터,LIS,이분탐색,DP,최단거리,펜윅트리)

<br>


# 2강.알고리즘 성능평가 (복잡도가 낮을수록 프로그램 성능이 좋다)

## 시간복잡도: 특정한 크기의 입력에 대하여 알고리즘의 [수행시간]분석 //최고차항의 차수만
` n!(팩토리얼) > 2^n(지수시간) > n^3(삼차시간) > n^2(이차시간) > nlogn(로그선형시간) > N(선형시간) > logN(로그시간) > 1(상수시간)`
## 공간복잡도: 특정한 크기의 입력에 대하여 알고리즘의 메모리 사용량 분석
` O(n) `

## 빅오표기법
- 가장빠르게 증가하는 항만을 고려하는 표기법(극한의개념)


###  상수시간 시간복잡도O(1)로 취급되는 것들
- 입출력 print
- 곱,나누기,나머지,빼기
- 간단한 비교 if문. ex) if(a[2] == 2)
- 배열의 인덱스참조

### 시간복잡도 계산해보기 1)

```Python
array = [3,4,3,1,2]
summary = 0

for x in array(리스트객체): 
	summary += x (수행코드...)

print(summary)
# =>n이커지면서 프로그램성능에 영향을 받는 부분은? : for문 
```

### 시간복잡도 계산 2)
```python
for i in array:
 for j in array:
  temp = i * j 
  print(temp)
    #모든 이중반복문의 시간복잡도가 O(n^2)은 아니다, 내부 로직까지 모두 검토해보고 결정해야함.
```

### 요구사항에 따라 적절한 알고리즘 설계하기

>N=500 => O(N^3)
2000=> N^2
100000=> NlogN
10000000=> O(N)인 알고리즘을 설계하면 문제를 풀 수 있음.

- 문제를 온전히 이해하고 코드작성하기


<br>

# 3강. 파이썬 문법 - 수 자료형

## 정수형(int)
- 양의정수,음의정수 ,0 


## 실수형
- 소수점 아래의 데이터를 처리하는 수 자료형
- `유효숫자`e^지수 =  `유효숫자`x10^지수 
    - 유효숫자(e,E)를 통해 나타낸 숫자는 실수형으로 처리된다. ex) 10000000.0
- `최단경로문제`에서는 도달할 수 없는 노드에 대하여 최단거리를 `무한(INF)`으로 설정한다
    - 10억 ~ 1e^9 ~ 987654321
- 보통 컴퓨터 시스템은 수 데이터를 처리할 때 2진수 체계로 데이터를 처리하므로 컴퓨터는 실수를 정확히 표현하지 못한다 ( 0.3+0.6 != 0.9 ) 
- 소수점 값을 비교해야하는 경우 round(실수형자료, 반올림하고자 하는 위치-1)함수를 사용한다.

## 수자료형의 연산 
- 사칙연산 + 나머지%연산자
- 나누기 a/b
- 나머지 a%b
- 몫 a//b
- 거듭제곱 a**b //a^b


<br>

# 4강. 리스트자료형

## 리스트 인덱싱,슬라이싱
- 인덱싱: 리스트[index] 형태로 원소에 접근하는 것
// a[-1] : a리스트의 마지막 원소를 참조 

- 슬라이싱: 리스트에서 연속적인 위치를 갖는 원소들을 가져올 때
// a = [1,2,3,4,5]
// a[시작인덱스:끝인덱스-1]
// 즉, a[n:m]이면 인덱스 n번부터 ~ m-1번까지 가져온다.
// a[2:4] // [3,4]


## 리스트컴프리헨션 (리스트 초기화 문법)
- 대괄호[] 안에 조건문과 반복문을 넣어 간편하게 리스트를 초기화시킬 수 있는 방법
    - 반복문(변수생략가능) -> 조건문 -> 원소삽입 ] 순서로 해석한다.

ex) [ i for i in range(0,9) if i % 2 == 1 ] 

- for i in range(0,9)
    - for i in [0,1,2,3,4,5,6,7,8,9] 
    - for i in 리스트형객체
    - i가 리스트의 0~9까지 순회함.

- [i for i in range(0,9)]
    - i가 0~9까지 순회할때 그 때 그 값을 매번 리스트의 원소 i로 설정해서 리스트를 만듦.
  [0,1,2,3,4,5,6,7,8,9] 

## 리스트컴프리헨션 작성 순서
- [ 반복문 ] -> [ 원소(i) 반복문 ] -> [원소 반복문 조건문] 
 조건문을 만족하는 i만 포함된 리스트자료를 만든다.

- `array = [i for i in range(20) if i % 2 == 1]`
 [1,3,5,7,9 ... 19]
 


## 리스트만들기(좋은예시)
```python
n=4
m=3
array = [[0] * m for _ in range(n)]
print(array)
```
// n번 반복하는 반복문에서 0이 m개인 리스트가
n번 반복되는 리스트를 생성
ex) [ [0,0,0],[0,0,0],[0,0,0] ]
// 서로다른 리스트객체를 원소로 하는 리스트가 만들어짐.


## 잘못된 예시 
- 주의:  반복문을 거치지 않으면 동일 객체가 참조된다
```python
n=4
m=3
array [[0] * m ] * n 
# 생성된 리스트의 아이템은 모두 같은 참조값을 갖는 객체이다 .
```


## 언더바(_)는 언제 사용하는가?
- 파이썬에서는 반복을 수행하되 반복을 위한 변수의 값을 무시하고자 할 때 `언더바_`를 자주 사용한다.

```python
#code1
summary = 0 
for i in range(1,10):   #1~9까지 반복문 실행
    summary += i    	    #반복하며 i의 누적합을 구함
 print(summary)

#code2 (i 변수가 사용되지 않을 때)
"Hello World"를 5번 출력하기
for _ in range(5):    # for i in range(0,5)
	print("Hello World")  #코드블록(스코프)를 :와 indent로 구분한다.
```

## 리스트 관련 기타 메서드 

- list.append() 
  - 리스트에 원소 하나 삽입
  - O(1) 상수시간 
- list.sort() 
  - (기본 정렬 기능으로)리스트 오름차순 정렬 
  - O(NlogN)

- list.sort(reverse=True)
  - 내림차순 정렬
  - O(NlogN) 로그시간

- list.reverse()
  - 리스트 원소의 순서를 뒤집는다.
  - O(N) 선형시간

- list.insert(삽일할자료,삽입할 위치 인덱스)
  - 자료를 특정 위치에 삽입한다. 
  - O(N) 

- list.count(특정값)
  - 리스트에서 특정 값의 갯수를 반환
  - O(N)

- list.remove(특정 값)
  - 리스트에서 특정 값을 '하나만' 제거한다.
  - O(N)

<br>

## 리스트에서 특정 값을 가지는 원소를 모두 제거하기
```python
a = [1,2,3,4,5,5,5]
remove_set = {3,5} #집합 자료형
```
## remove_set에 포함되지 않은 값만 저장
`result = [ i for i in a if i not in remove_set]`
- 반복문: a속에 포함된 a에 대해 순회
- 조건문: remove_set집합 속에 포함되지 않은 i 일때,
- 조건을 만족하는 i값만을 list에 포함시킨다.
 




# 5강. 문자열,튜플 자료형

## 문자열 자료형
- 덧셈(+)은 문자열을 `연결(Concatenate)`시켜준다.
- 곱셉(*)은 n번 반복된 문자열을 만들어준다.
- 문자열도 인덱싱과 슬라이싱을 사용할 수 있지만,
리스트와의 차이점은 특정 인덱스값을 변경할 수 없다는 점이다.
// a[2] = 'c'와 같이 문자열에는 원소할당이 불가하다.
// 원시형자료이기 때문에 불변성(Immutable)을 지켜줘야함.

```python
a = "ABCDEF"
print(a[2 : 4]) //2번~3번인덱스까지 2개 
// CD 
```

## 튜플 자료형

- 한 번 선언하면 값을 변경할 수 없음
- 리스트는 대괄호[], 튜플은 소괄호()로 표기 
- 인덱싱, 슬라이싱 모두 가능함.


## 튜플을 사용하면 좋은 경우
- 서로 다른 성질의 데이터를 묶어서 관리할 때
// `최단경로 알고리즘`에서 (비용,노드번호) 형태로 사용

- 데이터의 나열을 `해싱(Hashing)의 키 값`으로 사용해야 할 떄
//튜플은 변경이 불가하므로 리스트와 다르게 `key값`으로 사용가능하다.

- 리스트보다 메모리를 효율적으로 사용해야 할 때

- 그래프 알고리즘

- 다익스트라 최단경로 알고리즘의 `우선순위 큐`구현시

<br>

## 사전 자료형과 집합 자료형의 특징
1. (리스트, 튜플)은 순서가 있기 때문에 `인덱싱`을 통해
자료형의 값을 얻을 수 있다.

2. (사전,집합) 자료형은 순서가 없기 때문에 인덱싱 사용이 불가
    - 사전의 키(Key)혹은 집합의 원소(Element)를 이용해
O(1) 상수시간의 시간복잡도로 조회한다.




## 파이썬 map(매핑콜백, 이터러블1, 이러터블2 …) 
- 각각의 원소에 어떠한 함수를 적용하고자 할 때 사용할 수 있음.

>map함수의 동작은 두 번째 인자로 들어온 반복 가능한 자료형 (리스트나 튜플등의 iterable자료형)을 첫 번째 인자로 들어온 함수에 하나씩 집어넣어서 함수를 수행하는 함수입니다.

- `이터러블자료형(2nd)`의 요소를 1st함수에 하나씩 순회시켜 `map객체`로 반환 (`map객체에 리스트 메서드를 활용하기 위해선 list() 함수로 형변환이 필요`)
    - **이터러블**(반복가능한 자료형)
        - 시퀀스(순서가있고 연속적인)객체: `리스트[],튜플(),문자열str,range객체`
        - *시퀀스객체는 indexing,slicing이 가능하다.*

        - `Dict{},Set{}`: 순서가 없고 시퀀스객체가 아님.


- `(맵객체는 패킹된 상태로 반환됨)=>   a, b, c = map() 으로 각 변수에 분할해 할당하는 _언패킹_이 가능함.` 



>예시)
list1 = [1,2,3,4,5]  
list2 = [6,7,8,9,10]

result = map(lambda a,b: a+b, list1 , list2)       // list1, 2의 원소는 매핑함수의 파라미터 a,b로 순차로 들어가며 순회한다
print ( list(result) )    //결과값을 리스트로 형변환 (map함수 결과값은 map객체이기때문, 활용을위해 형변환 필요)

<br>

## 람다함수

`lambda a,b: 리턴값 `  
- 익명함수,편의문법(like arrow fn)
- 한번 사용하고 버리는 함수
- 정렬의 매핑함수에 사용하고 버리는형태로 자주 사용함.
>sorted(array, 정렬기준함수) ~ 정렬기준함수의 파라미터로는 array의 요소가 순회하고, 리턴값을 기준으로 정수,오름차순정렬

<br>

## 파이썬함수
- 패킹: 함수의 리턴값을 여러개로 묶어서 반환하기
- 언패킹: 패킹한 리턴값을 각각의 변수에 나눠담기

```python
def operator(a,b):
	add_var = a+b
	subtract_var = a-b
	multiply_var = a*b
	divide_var = a / b 
	return add_var , subtract_var , multiply_var , divide_var 	//Packing

a,b,c,d = operator(7 ,3)	//unpacking     //   나눠담을변수 = 패킹한리턴값
print(a, b, c, d)
```

<br>

## 실전에서 유용한 표준 라이브러리
### 1.내장함수
-파이썬에서 프로그램 작성시 없어서는 안 될 필수적인 기능 포함

ex) eval()
result = eval(“(3+5)*7”);
print(result) 
- 사람입장에서 수식으로 표현된 하나의 식이 있을 때
그 결과를 실제 수 형태로  반환해주는 함수

### 2.itertools
- 파이썬에서 반복되는 형태의 데이터(이터러블)을 처리하기 위한
유용한 기능들을 제공합니다.
- 특히 순열과 조합 라이브러리는 코테에서 자주 사용됨

### 3.heapq
- 힙 자료구조를 제공합니다.
  - 일반적으로 우선순위 큐 기능을 구현하기 위해 사용됩니다.

### 4.bisect
- 이진탐색(Binary Search)기능을 제공합니다.

### 5.collections
- deque,counter 등의 자료구조를 포함함

### 6.math
- 필수적인 수학적 기능을 제공
- 팩토리얼,제곱근,최대공약수,삼각함수 관련부터 파이같은 상수까지


<br>

## 정렬함수  
`sorted(정렬할 이터러블(:리스트,튜플..) , [옵션:정렬함수], reverse:boolean)`
- reverse (default: false =오름차순, true = 내림차순) 

<br>

## 파이썬 전역/지역 스코프 판단기준 : def함수 


## 순열과 조합

>순열: 서로다른 n개에서 서로 다른 r개를 선택하여 일렬로 나열하는 것
// nPr = n * n-1 * n-2 * ….n-r+1
// ABC ACB BAC BCA CAB CBA…

>조합: 서로다른 n개에서 순서 상관 없이 서로다른 r개 선택하는 것
// nCr = n * n-1 * n-2 * ….n-r+1 / r! 
// {A,B,C}에서 순서 고려 없이 2개 뽑느경우 = >AB AC BC 


<br>

## 그리디 문제 해결법
가장 좋아보이는 해를 그대로 따라간다.
(차분하게 문제 분석, 아이디어 단순화, 느낌이 오는 해가 최적해,
=>아이큐테스트에 가까운 평이한 문제)
- 자잘한 알고리즘 테스트

- 1.원하는 결과값을 담는 변수
- 2.결과값을 구하기 위해 필요한 변수 1,2,3,4 ….
- 3.입출력방식 
- 4.sort 및 for i in data 순회 적용여부
- 5.변수는 for in 순회하며 (초기화시키지 않는이상) 누적된다.

<br>

## 구현 
**: 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정.**

흔히 알고리즘 대회에서 구현 유형의 문제란?
: 풀이를 떠올리는 것은 쉽지만, 소스코드로 옮기기 어려운 문제를 지칭.

예시
- 알고리즘은 간단하지만 코드가 지나칠 만큼 길어지는 문제
- 실수 연산을다루고, 특정 소수점까지 출력해야 하는 문제
- 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제 (파이썬유리)
- 적절한 라이브러리르 찾아서 사용해야하는 문제 (itertools <-모든 순열이나 조합을 찾기 위한 문제)


출처:

[이것이 취업을위한 코딩테스트다_나동빈 저]

<br>

[파이썬 이터러블](https://sikaleo.tistory.com/61)
